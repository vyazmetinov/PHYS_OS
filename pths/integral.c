// Подключение заголовочных файлов
#include <math.h>        // Математические функции (sin)
#include <stdio.h>       // Стандартный ввод-вывод (printf)
#include <stdlib.h>      // Общие утилиты (atoi)
#include <pthread.h>     // POSIX потоки (pthread_create, pthread_mutex_*)

// Глобальный мьютекс для защиты общей переменной res
pthread_mutex_t mutex;

// Глобальная переменная-накопитель для суммы (интеграла)
double res = 0;


// Структура для передачи аргументов в поток
typedef struct {
    double x1;      // Левая граница отрезка
    double x2;      // Правая граница отрезка
} ThreadArgs;


// Функция, интеграл которой мы вычисляем: f(x) = sin(x)
double f(double x) {
    return sin(x);  // Возвращаем синус от x
}

// Функция для вычисления площади одной трапеции (выполняется в отдельном потоке)
void* square(void* args) {
    ThreadArgs* arg = (ThreadArgs*)args;  // Преобразуем аргумент к нужному типу
    double x1 = arg->x1;                  // Извлекаем левую границу
    double x2 = arg->x2;                  // Извлекаем правую границу
    
    // КРИТИЧЕСКАЯ СЕКЦИЯ: блокируем мьютекс перед изменением общей переменной
    pthread_mutex_lock(&mutex);
    // Вычисляем площадь трапеции и добавляем к общей сумме
    // Формула: S = (f(x1) + f(x2)) / 2 * (x2 - x1)
    res += (f(x1) + f(x2)) / 2 * (x2 - x1);
    // Разблокируем мьютекс - теперь другие потоки могут работать с res
    pthread_mutex_unlock(&mutex);
    
    return NULL;  // Завершаем поток
}

// Главная функция программы
int main(int argc, char *argv[]) {
    double a = atoi(argv[1]);             // Нижняя граница интегрирования (из аргумента)
    double b = atoi(argv[2]);             // Верхняя граница интегрирования (из аргумента)
    int n = 1e5;                          // Количество разбиений (100 000)
    double step = (b - a) / (double) n;   // Ширина одного отрезка
    
    // Инициализируем мьютекс с настройками по умолчанию
    pthread_mutex_init(&mutex, NULL);
    
    pthread_t threads[n];  // Массив для хранения дескрипторов потоков

    // Цикл по всем отрезкам
    for (int i = 0; i < n; i++) {
        ThreadArgs args_i;                    // Создаём структуру с аргументами
        args_i.x1 = a + i * step;             // Левая граница i-го отрезка
        args_i.x2 = a + (i + 1) * step;       // Правая граница i-го отрезка
        
        // Создаём новый поток для вычисления площади трапеции
        pthread_create(&threads[i], NULL, square, &args_i);
        
        // Сразу ждём завершения потока (последовательное выполнение)
        pthread_join(threads[i], NULL);
        
        // Выводим промежуточный результат на каждом шаге
        printf("res = %f, i = %f\n", res, (i + 1) * step);
    }

    // Уничтожаем мьютекс (освобождаем ресурсы)
    pthread_mutex_destroy(&mutex);
    
    // Выводим итоговые результаты
    printf("sise: %d\n", (int)((b - a) / step) + 1);  // Количество точек разбиения
    printf("res: %f\n", res);                           // Значение интеграла
    
    return 0;  // Успешное завершение программы
}

