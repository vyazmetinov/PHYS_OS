# Интегрирование с pthread и очередями сообщений

## Описание

Программа для вычисления определенного интеграла методом трапеций с использованием:
- **pthread** - для параллельных вычислений в потоках
- **Очереди сообщений System V (msgq)** - для передачи результатов от потоков к главному процессу

## Архитектура

```
┌─────────────────────┐
│  Главный поток      │
│  (создает очередь)  │
└──────────┬──────────┘
           │
           ├─────────────────────────┐
           │                         │
    ┌──────▼──────┐          ┌──────▼──────┐
    │  Поток 1    │          │  Поток 2    │
    │ (вычисляет) │   ...    │ (вычисляет) │
    └──────┬──────┘          └──────┬──────┘
           │                         │
           └─────────┬───────────────┘
                     │
           ┌─────────▼─────────┐
           │ Очередь сообщений │
           │   (результаты)    │
           └─────────┬─────────┘
                     │
           ┌─────────▼─────────┐
           │  Главный поток    │
           │ (собирает итоги)  │
           └───────────────────┘
```

## Как это работает

1. **Главный поток** создает очередь сообщений System V
2. Запускаются **N потоков** (по умолчанию 3), каждый получает свой подотрезок
3. Каждый **поток** вычисляет интеграл на своем отрезке
4. Поток **отправляет результат** в очередь сообщений через `msgsnd()`
5. **Главный поток** получает результаты через `msgrcv()` и суммирует их
6. После завершения очередь сообщений удаляется

## Компиляция

```bash
cd /Users/ivan/CLionProjects/Phys_OS/pths
gcc -o itg.out itg.c -lm -lpthread
```

## Запуск

### Режим непрерывной функции f(x) = sqrt(x)

```bash
./itg.out cont <начало> <конец> <точность>
```

**Примеры:**

```bash
# Интеграл от 0 до 4
./itg.out cont 0 4 0.01

# Интеграл от 1 до 9
./itg.out cont 1 9 0.001

# Интеграл от 1 до 16
./itg.out cont 1 16 0.001
```

### Режим дискретных данных

```bash
./itg.out n x1 x2 ... xn y1 y2 ... yn a b eps
```

**Пример:**

```bash
./itg.out 5 0 1 2 3 4 0 1 1.414 1.732 2 1 5 0.01
```

## Пример вывода

```
=== Режим непрерывной функции f(x) = sqrt(x) ===
Интервал: [0.000000, 4.000000], eps=0.010000

[Главный поток] Создана очередь сообщений (ID=131074)
[Главный поток] Запущено 3 потоков, ожидаю результаты...

CONT: from_x=0.000000 to_x=1.333333
CONT: h = 0.133333
CONT: result = 1.016921 (iterations: 10)
[Поток 0] Отправлен результат: 1.016921 (отрезок [0.000000, 1.333333])

CONT: from_x=1.333333 to_x=2.666667
CONT: h = 0.133333
CONT: result = 1.876511 (iterations: 10)
[Поток 1] Отправлен результат: 1.876511 (отрезок [1.333333, 2.666667])

CONT: from_x=2.666667 to_x=4.000000
CONT: h = 0.133333
CONT: result = 2.430151 (iterations: 11)
[Поток 2] Отправлен результат: 2.430151 (отрезок [2.666667, 4.000000])

[Главный поток] Получен результат от потока 0: 1.016921
[Главный поток] Получен результат от потока 1: 1.876511
[Главный поток] Получен результат от потока 2: 2.430151
[Главный поток] Очередь сообщений удалена

=== РЕЗУЛЬТАТ (непрерывный) = 5.323582 ===
```

## Структура сообщения

```c
typedef struct {
    long mtype;           // Тип сообщения (всегда = 1)
    int thread_id;        // ID потока
    double from_val;      // Начало отрезка
    double to_val;        // Конец отрезка
    double result;        // Вычисленный результат
} msg_result_t;
```

## Преимущества такого подхода

1. **Разделение вычислений и передачи данных**
   - Потоки изолированы и не зависят друг от друга
   - Очередь сообщений гарантирует безопасную передачу данных

2. **Масштабируемость**
   - Легко изменить количество потоков
   - Результаты могут обрабатываться асинхронно

3. **Отказоустойчивость**
   - Если поток упадет, очередь сохранит уже отправленные результаты
   - Главный процесс может контролировать таймауты

4. **Наблюдаемость**
   - Можно мониторить состояние очереди через `ipcs`
   - Видно, какие потоки отправили результаты

## Системные команды для работы с очередями

### Просмотр активных очередей

```bash
ipcs -q
```

### Удаление очереди вручную

```bash
ipcrm -q <msgid>
```

### Очистка всех очередей

```bash
ipcs -q | grep $(whoami) | awk '{print $2}' | xargs -I {} ipcrm -q {}
```

## Настройка количества потоков

По умолчанию используется 3 потока. Для изменения отредактируйте константу:

```c
const int pthread_amnt = 3;  // Измените на нужное число
```

Затем пересоберите программу.

## Отладка

Если программа не работает:

1. **Проверьте лимиты системы:**
   ```bash
   ipcs -l
   ```

2. **Очистите старые очереди:**
   ```bash
   ipcs -q | grep $(whoami) | awk '{print $2}' | xargs -I {} ipcrm -q {}
   ```

3. **Проверьте права доступа:**
   - Программа создает очередь с правами `0666`
   - Убедитесь, что у вас есть права на создание IPC объектов

## Отличия от версии с потоками без очередей

| Аспект | Без очередей | С очередями |
|--------|--------------|-------------|
| Передача данных | Через структуру в памяти | Через очередь сообщений |
| Синхронизация | pthread_join() | msgrcv() |
| Изоляция | Общая память | Копирование данных |
| Overhead | Минимальный | Небольшой (системные вызовы) |
| Отказоустойчивость | Низкая | Высокая |

## Применение

Такой подход полезен когда:
- Нужна надежная передача результатов
- Требуется мониторинг процесса вычислений
- Важна изоляция между потоками
- Планируется расширение до распределенной системы

## Ограничения

1. Системные лимиты на количество очередей
2. Небольшой overhead на системные вызовы
3. Требуются права на создание IPC объектов

